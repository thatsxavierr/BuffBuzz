generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserType {
  STUDENT
  PROFESSOR
}

enum VerificationStatus {
  PENDING
  VERIFIED
  FAILED
}

enum PrivacyLevel {
  PUBLIC
  FRIENDS_ONLY
  PRIVATE
}

model User {
  id                          String                       @id @default(uuid())
  email                       String                       @unique
  password                    String
  firstName                   String
  lastName                    String
  userType                    UserType
  verificationStatus          VerificationStatus           @default(PENDING)
  verificationCode            String?
  verificationAttempts        Int                          @default(0)
  resetToken                  String?
  resetTokenExpiry            DateTime?
  createdAt                   DateTime                     @default(now())
  updatedAt                   DateTime                     @updatedAt
  
  // Relations
  profile                     Profile?
  posts                       Post[]
  comments                    Comment[]
  likes                       Like[]
  shares                      Share[]
  notificationPreferences     NotificationPreferences?
  jobs                        Job[]
  marketplaceItems            MarketplaceItem[]
  lostFoundItems              LostFoundItem[]
  createdGroups               Group[]                      @relation("GroupCreator")
  groupMemberships            GroupMember[]
  conversations               ConversationParticipant[]
  messages                    Message[]                    @relation("MessageSender")
  messageReactions            MessageReaction[]
  
  // Friendships
  sentFriendships             Friendship[]                 @relation("FriendshipSender")
  receivedFriendships         Friendship[]                 @relation("FriendshipReceiver")
  
  // Blocks
  blocksMade                  Block[]                      @relation("BlockerRelation")
  blocksReceived              Block[]                      @relation("BlockedRelation")

  @@map("users")
}

model Profile {
  id                String        @id @default(uuid())
  userId            String        @unique
  user              User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  name              String?
  pronouns          String?
  bio               String?
  major             String?
  department        String?
  graduationYear    String?
  classification    String?
  clubs             String?
  
  // Social Media
  instagramHandle   String?
  linkedinUrl       String?
  facebookHandle    String?
  
  // Profile Picture
  profilePictureUrl String?
  
  // Privacy Settings
  privacy           PrivacyLevel  @default(PUBLIC)

  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt

  @@map("profiles")
}

model NotificationPreferences {
  id                    String   @id @default(uuid())
  userId                String   @unique
  user                  User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  emailNotifications    Boolean  @default(true)
  pushNotifications     Boolean  @default(true)
  postLikes             Boolean  @default(true)
  comments              Boolean  @default(true)
  newFollowers          Boolean  @default(true)
  
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@map("notification_preferences")
}

model Post {
  id          String    @id @default(uuid())
  title       String
  content     String
  imageUrl    String?
  
  authorId    String
  author      User      @relation(fields: [authorId], references: [id], onDelete: Cascade)
  
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  // Relations
  comments    Comment[]
  likes       Like[]
  shares      Share[]

  @@map("posts")
  @@index([authorId])
  @@index([createdAt])
}

model Comment {
  id          String   @id @default(uuid())
  content     String
  
  postId      String
  post        Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  
  authorId    String
  author      User     @relation(fields: [authorId], references: [id], onDelete: Cascade)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("comments")
  @@index([postId])
  @@index([authorId])
}

model Like {
  id          String   @id @default(uuid())
  
  postId      String
  post        Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt   DateTime @default(now())

  @@unique([postId, userId])
  @@map("likes")
  @@index([postId])
  @@index([userId])
}

model Share {
  id          String   @id @default(uuid())
  
  postId      String
  post        Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt   DateTime @default(now())

  @@map("shares")
  @@index([postId])
  @@index([userId])
}

model Friendship {
  id              String   @id @default(uuid())
  
  senderId        String
  sender          User     @relation("FriendshipSender", fields: [senderId], references: [id], onDelete: Cascade)
  
  receiverId      String
  receiver        User     @relation("FriendshipReceiver", fields: [receiverId], references: [id], onDelete: Cascade)
  
  status          String   @default("PENDING") // PENDING, ACCEPTED
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([senderId, receiverId])
  @@map("friendships")
  @@index([senderId])
  @@index([receiverId])
  @@index([status])
}

model Block {
  id        String   @id @default(uuid())
  blockerId String   // User who is blocking
  blockedId String   // User being blocked
  createdAt DateTime @default(now())

  blocker User @relation("BlockerRelation", fields: [blockerId], references: [id], onDelete: Cascade)
  blocked User @relation("BlockedRelation", fields: [blockedId], references: [id], onDelete: Cascade)

  @@unique([blockerId, blockedId])
  @@map("blocks")
  @@index([blockerId])
  @@index([blockedId])
}

enum JobType {
  FULL_TIME
  PART_TIME
  CONTRACT
  INTERNSHIP
}

enum JobCategory {
  INTERNSHIP
  ON_CAMPUS
  REMOTE
  LOCAL
}

model Job {
  id              String      @id @default(uuid())
  title           String
  company         String
  location        String
  jobType         JobType
  category        JobCategory
  description     String      @db.Text
  requirements    String      @db.Text
  salary          String?
  applicationLink String
  
  posterId        String
  poster          User        @relation(fields: [posterId], references: [id], onDelete: Cascade)
  
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt

  @@map("jobs")
  @@index([posterId])
  @@index([category])
  @@index([jobType])
  @@index([createdAt])
}

enum MarketplaceCategory {
  TEXTBOOKS
  ELECTRONICS
  FURNITURE
  CLOTHING
  SCHOOL_SUPPLIES
  OTHER
}

enum ItemCondition {
  NEW
  LIKE_NEW
  GOOD
  FAIR
}

model MarketplaceItem {
  id          String              @id @default(uuid())
  title       String
  description String              @db.Text
  price       Decimal             @db.Decimal(10, 2)
  category    MarketplaceCategory
  condition   ItemCondition
  imageUrl    String?             @db.Text
  
  sellerId    String
  seller      User                @relation(fields: [sellerId], references: [id], onDelete: Cascade)
  
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt

  @@map("marketplace_items")
  @@index([sellerId])
  @@index([category])
  @@index([createdAt])
}

enum LostFoundCategory {
  LOST
  FOUND
}

model LostFoundItem {
  id          String              @id @default(uuid())
  title       String
  description String              @db.Text
  category    LostFoundCategory
  location    String
  date        DateTime
  contactInfo String
  imageUrl    String?             @db.Text
  
  userId      String
  user        User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt

  @@map("lostfound_items")
  @@index([userId])
  @@index([category])
  @@index([createdAt])
}

enum GroupCategory {
  ACADEMIC
  SPORTS
  ARTS
  SOCIAL
  PROFESSIONAL
  VOLUNTEER
  OTHER
}

enum GroupPrivacy {
  PUBLIC
  PRIVATE
}

model Group {
  id          String        @id @default(uuid())
  name        String
  description String        @db.Text
  category    GroupCategory
  privacy     GroupPrivacy  @default(PUBLIC)
  imageUrl    String?       @db.Text
  
  creatorId   String
  creator     User          @relation("GroupCreator", fields: [creatorId], references: [id], onDelete: Cascade)
  
  members     GroupMember[]
  
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  @@map("groups")
  @@index([creatorId])
  @@index([category])
  @@index([createdAt])
}

model GroupMember {
  id        String   @id @default(uuid())
  
  groupId   String
  group     Group    @relation(fields: [groupId], references: [id], onDelete: Cascade)
  
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  role      String   @default("MEMBER") // ADMIN, MEMBER
  joinedAt  DateTime @default(now())

  @@unique([groupId, userId])
  @@map("group_members")
  @@index([groupId])
  @@index([userId])
}

enum MessageType {
  TEXT
  IMAGE
}

model Conversation {
  id            String    @id @default(uuid())
  isGroupChat   Boolean   @default(false)
  name          String?   // For group chats
  imageUrl      String?   @db.Text // For group chat image
  creatorId     String?
  
  participants  ConversationParticipant[]
  messages      Message[]
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@map("conversations")
  @@index([createdAt])
}

model ConversationParticipant {
  id              String       @id @default(uuid())
  
  conversationId  String
  conversation    Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  
  userId          String
  user            User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  lastReadAt      DateTime?    // When user last read messages
  joinedAt        DateTime     @default(now())

  @@unique([conversationId, userId])
  @@map("conversation_participants")
  @@index([conversationId])
  @@index([userId])
}

model Message {
  id              String            @id @default(uuid())
  content         String            @db.Text
  type            MessageType       @default(TEXT)
  imageUrl        String?           @db.Text
  
  conversationId  String
  conversation    Conversation      @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  
  senderId        String
  sender          User              @relation("MessageSender", fields: [senderId], references: [id], onDelete: Cascade)
  
  replyToId       String?
  replyTo         Message?          @relation("MessageReplies", fields: [replyToId], references: [id], onDelete: SetNull)
  replies         Message[]         @relation("MessageReplies")
  
  reactions       MessageReaction[]
  
  deletedAt       DateTime?
  editedAt        DateTime?
  
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt

  @@map("messages")
  @@index([conversationId])
  @@index([senderId])
  @@index([createdAt])
}

model MessageReaction {
  id        String   @id @default(uuid())
  
  messageId String
  message   Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)
  
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  emoji     String   // The emoji used for reaction
  
  createdAt DateTime @default(now())

  @@unique([messageId, userId]) // One reaction per user per message
  @@map("message_reactions")
  @@index([messageId])
  @@index([userId])
}